// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/andrew-bodine/monitoring/pkg/monitors"
	gorpio "github.com/stianeikeland/go-rpio"
)

type FakeGoRaspberryPiIO struct {
	PinModeStub        func(pin monitors.GoRaspberryPiIOPin, mode gorpio.Mode)
	pinModeMutex       sync.RWMutex
	pinModeArgsForCall []struct {
		pin  monitors.GoRaspberryPiIOPin
		mode gorpio.Mode
	}
	WritePinStub        func(pin monitors.GoRaspberryPiIOPin, state gorpio.State)
	writePinMutex       sync.RWMutex
	writePinArgsForCall []struct {
		pin   monitors.GoRaspberryPiIOPin
		state gorpio.State
	}
	ReadPinStub        func(pin monitors.GoRaspberryPiIOPin) gorpio.State
	readPinMutex       sync.RWMutex
	readPinArgsForCall []struct {
		pin monitors.GoRaspberryPiIOPin
	}
	readPinReturns struct {
		result1 gorpio.State
	}
	readPinReturnsOnCall map[int]struct {
		result1 gorpio.State
	}
	TogglePinStub        func(pin monitors.GoRaspberryPiIOPin)
	togglePinMutex       sync.RWMutex
	togglePinArgsForCall []struct {
		pin monitors.GoRaspberryPiIOPin
	}
	DetectEdgeStub        func(pin monitors.GoRaspberryPiIOPin, edge gorpio.Edge)
	detectEdgeMutex       sync.RWMutex
	detectEdgeArgsForCall []struct {
		pin  monitors.GoRaspberryPiIOPin
		edge gorpio.Edge
	}
	EdgeDetectedStub        func(pin monitors.GoRaspberryPiIOPin) bool
	edgeDetectedMutex       sync.RWMutex
	edgeDetectedArgsForCall []struct {
		pin monitors.GoRaspberryPiIOPin
	}
	edgeDetectedReturns struct {
		result1 bool
	}
	edgeDetectedReturnsOnCall map[int]struct {
		result1 bool
	}
	PullModeStub        func(pin monitors.GoRaspberryPiIOPin, pull gorpio.Pull)
	pullModeMutex       sync.RWMutex
	pullModeArgsForCall []struct {
		pin  monitors.GoRaspberryPiIOPin
		pull gorpio.Pull
	}
	SetFreqStub        func(pin monitors.GoRaspberryPiIOPin, freq int)
	setFreqMutex       sync.RWMutex
	setFreqArgsForCall []struct {
		pin  monitors.GoRaspberryPiIOPin
		freq int
	}
	SetDutyCycleStub        func(pin monitors.GoRaspberryPiIOPin, dutyLen, cycleLen uint32)
	setDutyCycleMutex       sync.RWMutex
	setDutyCycleArgsForCall []struct {
		pin      monitors.GoRaspberryPiIOPin
		dutyLen  uint32
		cycleLen uint32
	}
	StopPwmStub           func()
	stopPwmMutex          sync.RWMutex
	stopPwmArgsForCall    []struct{}
	StartPwmStub          func()
	startPwmMutex         sync.RWMutex
	startPwmArgsForCall   []struct{}
	EnableIRQsStub        func(irqs uint64)
	enableIRQsMutex       sync.RWMutex
	enableIRQsArgsForCall []struct {
		irqs uint64
	}
	DisableIRQsStub        func(irqs uint64)
	disableIRQsMutex       sync.RWMutex
	disableIRQsArgsForCall []struct {
		irqs uint64
	}
	OpenStub        func() (err error)
	openMutex       sync.RWMutex
	openArgsForCall []struct{}
	openReturns     struct {
		result1 error
	}
	openReturnsOnCall map[int]struct {
		result1 error
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct{}
	closeReturns     struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGoRaspberryPiIO) PinMode(pin monitors.GoRaspberryPiIOPin, mode gorpio.Mode) {
	fake.pinModeMutex.Lock()
	fake.pinModeArgsForCall = append(fake.pinModeArgsForCall, struct {
		pin  monitors.GoRaspberryPiIOPin
		mode gorpio.Mode
	}{pin, mode})
	fake.recordInvocation("PinMode", []interface{}{pin, mode})
	fake.pinModeMutex.Unlock()
	if fake.PinModeStub != nil {
		fake.PinModeStub(pin, mode)
	}
}

func (fake *FakeGoRaspberryPiIO) PinModeCallCount() int {
	fake.pinModeMutex.RLock()
	defer fake.pinModeMutex.RUnlock()
	return len(fake.pinModeArgsForCall)
}

func (fake *FakeGoRaspberryPiIO) PinModeArgsForCall(i int) (monitors.GoRaspberryPiIOPin, gorpio.Mode) {
	fake.pinModeMutex.RLock()
	defer fake.pinModeMutex.RUnlock()
	return fake.pinModeArgsForCall[i].pin, fake.pinModeArgsForCall[i].mode
}

func (fake *FakeGoRaspberryPiIO) WritePin(pin monitors.GoRaspberryPiIOPin, state gorpio.State) {
	fake.writePinMutex.Lock()
	fake.writePinArgsForCall = append(fake.writePinArgsForCall, struct {
		pin   monitors.GoRaspberryPiIOPin
		state gorpio.State
	}{pin, state})
	fake.recordInvocation("WritePin", []interface{}{pin, state})
	fake.writePinMutex.Unlock()
	if fake.WritePinStub != nil {
		fake.WritePinStub(pin, state)
	}
}

func (fake *FakeGoRaspberryPiIO) WritePinCallCount() int {
	fake.writePinMutex.RLock()
	defer fake.writePinMutex.RUnlock()
	return len(fake.writePinArgsForCall)
}

func (fake *FakeGoRaspberryPiIO) WritePinArgsForCall(i int) (monitors.GoRaspberryPiIOPin, gorpio.State) {
	fake.writePinMutex.RLock()
	defer fake.writePinMutex.RUnlock()
	return fake.writePinArgsForCall[i].pin, fake.writePinArgsForCall[i].state
}

func (fake *FakeGoRaspberryPiIO) ReadPin(pin monitors.GoRaspberryPiIOPin) gorpio.State {
	fake.readPinMutex.Lock()
	ret, specificReturn := fake.readPinReturnsOnCall[len(fake.readPinArgsForCall)]
	fake.readPinArgsForCall = append(fake.readPinArgsForCall, struct {
		pin monitors.GoRaspberryPiIOPin
	}{pin})
	fake.recordInvocation("ReadPin", []interface{}{pin})
	fake.readPinMutex.Unlock()
	if fake.ReadPinStub != nil {
		return fake.ReadPinStub(pin)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.readPinReturns.result1
}

func (fake *FakeGoRaspberryPiIO) ReadPinCallCount() int {
	fake.readPinMutex.RLock()
	defer fake.readPinMutex.RUnlock()
	return len(fake.readPinArgsForCall)
}

func (fake *FakeGoRaspberryPiIO) ReadPinArgsForCall(i int) monitors.GoRaspberryPiIOPin {
	fake.readPinMutex.RLock()
	defer fake.readPinMutex.RUnlock()
	return fake.readPinArgsForCall[i].pin
}

func (fake *FakeGoRaspberryPiIO) ReadPinReturns(result1 gorpio.State) {
	fake.ReadPinStub = nil
	fake.readPinReturns = struct {
		result1 gorpio.State
	}{result1}
}

func (fake *FakeGoRaspberryPiIO) ReadPinReturnsOnCall(i int, result1 gorpio.State) {
	fake.ReadPinStub = nil
	if fake.readPinReturnsOnCall == nil {
		fake.readPinReturnsOnCall = make(map[int]struct {
			result1 gorpio.State
		})
	}
	fake.readPinReturnsOnCall[i] = struct {
		result1 gorpio.State
	}{result1}
}

func (fake *FakeGoRaspberryPiIO) TogglePin(pin monitors.GoRaspberryPiIOPin) {
	fake.togglePinMutex.Lock()
	fake.togglePinArgsForCall = append(fake.togglePinArgsForCall, struct {
		pin monitors.GoRaspberryPiIOPin
	}{pin})
	fake.recordInvocation("TogglePin", []interface{}{pin})
	fake.togglePinMutex.Unlock()
	if fake.TogglePinStub != nil {
		fake.TogglePinStub(pin)
	}
}

func (fake *FakeGoRaspberryPiIO) TogglePinCallCount() int {
	fake.togglePinMutex.RLock()
	defer fake.togglePinMutex.RUnlock()
	return len(fake.togglePinArgsForCall)
}

func (fake *FakeGoRaspberryPiIO) TogglePinArgsForCall(i int) monitors.GoRaspberryPiIOPin {
	fake.togglePinMutex.RLock()
	defer fake.togglePinMutex.RUnlock()
	return fake.togglePinArgsForCall[i].pin
}

func (fake *FakeGoRaspberryPiIO) DetectEdge(pin monitors.GoRaspberryPiIOPin, edge gorpio.Edge) {
	fake.detectEdgeMutex.Lock()
	fake.detectEdgeArgsForCall = append(fake.detectEdgeArgsForCall, struct {
		pin  monitors.GoRaspberryPiIOPin
		edge gorpio.Edge
	}{pin, edge})
	fake.recordInvocation("DetectEdge", []interface{}{pin, edge})
	fake.detectEdgeMutex.Unlock()
	if fake.DetectEdgeStub != nil {
		fake.DetectEdgeStub(pin, edge)
	}
}

func (fake *FakeGoRaspberryPiIO) DetectEdgeCallCount() int {
	fake.detectEdgeMutex.RLock()
	defer fake.detectEdgeMutex.RUnlock()
	return len(fake.detectEdgeArgsForCall)
}

func (fake *FakeGoRaspberryPiIO) DetectEdgeArgsForCall(i int) (monitors.GoRaspberryPiIOPin, gorpio.Edge) {
	fake.detectEdgeMutex.RLock()
	defer fake.detectEdgeMutex.RUnlock()
	return fake.detectEdgeArgsForCall[i].pin, fake.detectEdgeArgsForCall[i].edge
}

func (fake *FakeGoRaspberryPiIO) EdgeDetected(pin monitors.GoRaspberryPiIOPin) bool {
	fake.edgeDetectedMutex.Lock()
	ret, specificReturn := fake.edgeDetectedReturnsOnCall[len(fake.edgeDetectedArgsForCall)]
	fake.edgeDetectedArgsForCall = append(fake.edgeDetectedArgsForCall, struct {
		pin monitors.GoRaspberryPiIOPin
	}{pin})
	fake.recordInvocation("EdgeDetected", []interface{}{pin})
	fake.edgeDetectedMutex.Unlock()
	if fake.EdgeDetectedStub != nil {
		return fake.EdgeDetectedStub(pin)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.edgeDetectedReturns.result1
}

func (fake *FakeGoRaspberryPiIO) EdgeDetectedCallCount() int {
	fake.edgeDetectedMutex.RLock()
	defer fake.edgeDetectedMutex.RUnlock()
	return len(fake.edgeDetectedArgsForCall)
}

func (fake *FakeGoRaspberryPiIO) EdgeDetectedArgsForCall(i int) monitors.GoRaspberryPiIOPin {
	fake.edgeDetectedMutex.RLock()
	defer fake.edgeDetectedMutex.RUnlock()
	return fake.edgeDetectedArgsForCall[i].pin
}

func (fake *FakeGoRaspberryPiIO) EdgeDetectedReturns(result1 bool) {
	fake.EdgeDetectedStub = nil
	fake.edgeDetectedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeGoRaspberryPiIO) EdgeDetectedReturnsOnCall(i int, result1 bool) {
	fake.EdgeDetectedStub = nil
	if fake.edgeDetectedReturnsOnCall == nil {
		fake.edgeDetectedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.edgeDetectedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeGoRaspberryPiIO) PullMode(pin monitors.GoRaspberryPiIOPin, pull gorpio.Pull) {
	fake.pullModeMutex.Lock()
	fake.pullModeArgsForCall = append(fake.pullModeArgsForCall, struct {
		pin  monitors.GoRaspberryPiIOPin
		pull gorpio.Pull
	}{pin, pull})
	fake.recordInvocation("PullMode", []interface{}{pin, pull})
	fake.pullModeMutex.Unlock()
	if fake.PullModeStub != nil {
		fake.PullModeStub(pin, pull)
	}
}

func (fake *FakeGoRaspberryPiIO) PullModeCallCount() int {
	fake.pullModeMutex.RLock()
	defer fake.pullModeMutex.RUnlock()
	return len(fake.pullModeArgsForCall)
}

func (fake *FakeGoRaspberryPiIO) PullModeArgsForCall(i int) (monitors.GoRaspberryPiIOPin, gorpio.Pull) {
	fake.pullModeMutex.RLock()
	defer fake.pullModeMutex.RUnlock()
	return fake.pullModeArgsForCall[i].pin, fake.pullModeArgsForCall[i].pull
}

func (fake *FakeGoRaspberryPiIO) SetFreq(pin monitors.GoRaspberryPiIOPin, freq int) {
	fake.setFreqMutex.Lock()
	fake.setFreqArgsForCall = append(fake.setFreqArgsForCall, struct {
		pin  monitors.GoRaspberryPiIOPin
		freq int
	}{pin, freq})
	fake.recordInvocation("SetFreq", []interface{}{pin, freq})
	fake.setFreqMutex.Unlock()
	if fake.SetFreqStub != nil {
		fake.SetFreqStub(pin, freq)
	}
}

func (fake *FakeGoRaspberryPiIO) SetFreqCallCount() int {
	fake.setFreqMutex.RLock()
	defer fake.setFreqMutex.RUnlock()
	return len(fake.setFreqArgsForCall)
}

func (fake *FakeGoRaspberryPiIO) SetFreqArgsForCall(i int) (monitors.GoRaspberryPiIOPin, int) {
	fake.setFreqMutex.RLock()
	defer fake.setFreqMutex.RUnlock()
	return fake.setFreqArgsForCall[i].pin, fake.setFreqArgsForCall[i].freq
}

func (fake *FakeGoRaspberryPiIO) SetDutyCycle(pin monitors.GoRaspberryPiIOPin, dutyLen uint32, cycleLen uint32) {
	fake.setDutyCycleMutex.Lock()
	fake.setDutyCycleArgsForCall = append(fake.setDutyCycleArgsForCall, struct {
		pin      monitors.GoRaspberryPiIOPin
		dutyLen  uint32
		cycleLen uint32
	}{pin, dutyLen, cycleLen})
	fake.recordInvocation("SetDutyCycle", []interface{}{pin, dutyLen, cycleLen})
	fake.setDutyCycleMutex.Unlock()
	if fake.SetDutyCycleStub != nil {
		fake.SetDutyCycleStub(pin, dutyLen, cycleLen)
	}
}

func (fake *FakeGoRaspberryPiIO) SetDutyCycleCallCount() int {
	fake.setDutyCycleMutex.RLock()
	defer fake.setDutyCycleMutex.RUnlock()
	return len(fake.setDutyCycleArgsForCall)
}

func (fake *FakeGoRaspberryPiIO) SetDutyCycleArgsForCall(i int) (monitors.GoRaspberryPiIOPin, uint32, uint32) {
	fake.setDutyCycleMutex.RLock()
	defer fake.setDutyCycleMutex.RUnlock()
	return fake.setDutyCycleArgsForCall[i].pin, fake.setDutyCycleArgsForCall[i].dutyLen, fake.setDutyCycleArgsForCall[i].cycleLen
}

func (fake *FakeGoRaspberryPiIO) StopPwm() {
	fake.stopPwmMutex.Lock()
	fake.stopPwmArgsForCall = append(fake.stopPwmArgsForCall, struct{}{})
	fake.recordInvocation("StopPwm", []interface{}{})
	fake.stopPwmMutex.Unlock()
	if fake.StopPwmStub != nil {
		fake.StopPwmStub()
	}
}

func (fake *FakeGoRaspberryPiIO) StopPwmCallCount() int {
	fake.stopPwmMutex.RLock()
	defer fake.stopPwmMutex.RUnlock()
	return len(fake.stopPwmArgsForCall)
}

func (fake *FakeGoRaspberryPiIO) StartPwm() {
	fake.startPwmMutex.Lock()
	fake.startPwmArgsForCall = append(fake.startPwmArgsForCall, struct{}{})
	fake.recordInvocation("StartPwm", []interface{}{})
	fake.startPwmMutex.Unlock()
	if fake.StartPwmStub != nil {
		fake.StartPwmStub()
	}
}

func (fake *FakeGoRaspberryPiIO) StartPwmCallCount() int {
	fake.startPwmMutex.RLock()
	defer fake.startPwmMutex.RUnlock()
	return len(fake.startPwmArgsForCall)
}

func (fake *FakeGoRaspberryPiIO) EnableIRQs(irqs uint64) {
	fake.enableIRQsMutex.Lock()
	fake.enableIRQsArgsForCall = append(fake.enableIRQsArgsForCall, struct {
		irqs uint64
	}{irqs})
	fake.recordInvocation("EnableIRQs", []interface{}{irqs})
	fake.enableIRQsMutex.Unlock()
	if fake.EnableIRQsStub != nil {
		fake.EnableIRQsStub(irqs)
	}
}

func (fake *FakeGoRaspberryPiIO) EnableIRQsCallCount() int {
	fake.enableIRQsMutex.RLock()
	defer fake.enableIRQsMutex.RUnlock()
	return len(fake.enableIRQsArgsForCall)
}

func (fake *FakeGoRaspberryPiIO) EnableIRQsArgsForCall(i int) uint64 {
	fake.enableIRQsMutex.RLock()
	defer fake.enableIRQsMutex.RUnlock()
	return fake.enableIRQsArgsForCall[i].irqs
}

func (fake *FakeGoRaspberryPiIO) DisableIRQs(irqs uint64) {
	fake.disableIRQsMutex.Lock()
	fake.disableIRQsArgsForCall = append(fake.disableIRQsArgsForCall, struct {
		irqs uint64
	}{irqs})
	fake.recordInvocation("DisableIRQs", []interface{}{irqs})
	fake.disableIRQsMutex.Unlock()
	if fake.DisableIRQsStub != nil {
		fake.DisableIRQsStub(irqs)
	}
}

func (fake *FakeGoRaspberryPiIO) DisableIRQsCallCount() int {
	fake.disableIRQsMutex.RLock()
	defer fake.disableIRQsMutex.RUnlock()
	return len(fake.disableIRQsArgsForCall)
}

func (fake *FakeGoRaspberryPiIO) DisableIRQsArgsForCall(i int) uint64 {
	fake.disableIRQsMutex.RLock()
	defer fake.disableIRQsMutex.RUnlock()
	return fake.disableIRQsArgsForCall[i].irqs
}

func (fake *FakeGoRaspberryPiIO) Open() (err error) {
	fake.openMutex.Lock()
	ret, specificReturn := fake.openReturnsOnCall[len(fake.openArgsForCall)]
	fake.openArgsForCall = append(fake.openArgsForCall, struct{}{})
	fake.recordInvocation("Open", []interface{}{})
	fake.openMutex.Unlock()
	if fake.OpenStub != nil {
		return fake.OpenStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.openReturns.result1
}

func (fake *FakeGoRaspberryPiIO) OpenCallCount() int {
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	return len(fake.openArgsForCall)
}

func (fake *FakeGoRaspberryPiIO) OpenReturns(result1 error) {
	fake.OpenStub = nil
	fake.openReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGoRaspberryPiIO) OpenReturnsOnCall(i int, result1 error) {
	fake.OpenStub = nil
	if fake.openReturnsOnCall == nil {
		fake.openReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.openReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGoRaspberryPiIO) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct{}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		return fake.CloseStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.closeReturns.result1
}

func (fake *FakeGoRaspberryPiIO) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeGoRaspberryPiIO) CloseReturns(result1 error) {
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGoRaspberryPiIO) CloseReturnsOnCall(i int, result1 error) {
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGoRaspberryPiIO) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.pinModeMutex.RLock()
	defer fake.pinModeMutex.RUnlock()
	fake.writePinMutex.RLock()
	defer fake.writePinMutex.RUnlock()
	fake.readPinMutex.RLock()
	defer fake.readPinMutex.RUnlock()
	fake.togglePinMutex.RLock()
	defer fake.togglePinMutex.RUnlock()
	fake.detectEdgeMutex.RLock()
	defer fake.detectEdgeMutex.RUnlock()
	fake.edgeDetectedMutex.RLock()
	defer fake.edgeDetectedMutex.RUnlock()
	fake.pullModeMutex.RLock()
	defer fake.pullModeMutex.RUnlock()
	fake.setFreqMutex.RLock()
	defer fake.setFreqMutex.RUnlock()
	fake.setDutyCycleMutex.RLock()
	defer fake.setDutyCycleMutex.RUnlock()
	fake.stopPwmMutex.RLock()
	defer fake.stopPwmMutex.RUnlock()
	fake.startPwmMutex.RLock()
	defer fake.startPwmMutex.RUnlock()
	fake.enableIRQsMutex.RLock()
	defer fake.enableIRQsMutex.RUnlock()
	fake.disableIRQsMutex.RLock()
	defer fake.disableIRQsMutex.RUnlock()
	fake.openMutex.RLock()
	defer fake.openMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGoRaspberryPiIO) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ monitors.GoRaspberryPiIO = new(FakeGoRaspberryPiIO)
